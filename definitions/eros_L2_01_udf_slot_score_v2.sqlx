config {
  type: "operations",
  hasOutput: false,
  tags: ["L2", "udf_slot_score_v2"],
  dependencies: ["eros_L1_01_reference_enums", "eros_L1_02_v_message_facts_by_page"],
  description: "====================================================================="
}

-- =====================================================================
-- EROS L2.01: Advanced Slot Scoring Engine - AI-Powered Decision Logic
-- =====================================================================
-- Next-generation slot scoring system with machine learning integration,
-- multi-objective optimization, and intelligent feature weighting.
-- =====================================================================

-- =====================================================================
-- ADVANCED SLOT SCORING UDF
-- =====================================================================

CREATE OR REPLACE FUNCTION `layer_02_features.calculate_slot_score_v2`(
  -- Creator context
  creator_tier STRING,
  creator_rpm_baseline NUMERIC,
  creator_conversion_baseline NUMERIC,
  creator_recent_trend NUMERIC,

  -- Content features
  content_category STRING,
  content_novelty_score NUMERIC,
  content_length INT64,
  content_has_price BOOL,
  content_has_personalization BOOL,
  content_historical_performance NUMERIC,

  -- Timing features
  send_hour INT64,
  send_dayofweek INT64,
  hours_since_last_send NUMERIC,
  fan_activity_score NUMERIC,

  -- Fan context
  fan_segment STRING,
  fan_engagement_history NUMERIC,
  fan_price_sensitivity NUMERIC,

  -- Environmental factors
  competitive_activity_score NUMERIC,
  seasonal_boost_factor NUMERIC,
  platform_health_score NUMERIC
)
RETURNS NUMERIC
LANGUAGE js AS """
  // Input validation
  if (!creator_tier || !content_category || send_hour < 0 || send_hour > 23) {
    return 0.0;
  }

  // Initialize base score components
  let baseScore = 0.0;
  let weights = {
    creator: 0.25,
    content: 0.30,
    timing: 0.25,
    fan: 0.15,
    environment: 0.05
  };

  // Creator component
  let creatorScore = 0.0;
  const tierMultipliers = {
    'PREMIUM': 1.2,
    'HIGH': 1.0,
    'MED': 0.8,
    'LOW': 0.6,
    'NEW': 0.4
  };

  creatorScore += (tierMultipliers[creator_tier] || 0.5) * 0.4;
  creatorScore += Math.min(creator_rpm_baseline / 2.0, 1.0) * 0.3;
  creatorScore += Math.min(creator_conversion_baseline / 0.1, 1.0) * 0.2;
  creatorScore += Math.max(0, Math.min(creator_recent_trend, 2.0)) * 0.1;

  // Content component
  let contentScore = 0.0;
  const categoryMultipliers = {
    'PPV': 1.0,
    'CUSTOM': 0.9,
    'TIP': 0.7,
    'BUMP': 0.6,
    'RENEW': 0.8
  };

  contentScore += (categoryMultipliers[content_category] || 0.5) * 0.3;
  contentScore += (content_novelty_score || 0.5) * 0.25;
  contentScore += (content_historical_performance || 0.5) * 0.25;

  // Content length optimization (bell curve)
  let lengthOptimal = 1.0;
  if (content_length < 30) lengthOptimal = 0.6;
  else if (content_length < 50) lengthOptimal = 0.8;
  else if (content_length <= 150) lengthOptimal = 1.0;
  else if (content_length <= 250) lengthOptimal = 0.9;
  else lengthOptimal = 0.7;
  contentScore += lengthOptimal * 0.1;

  // Content features bonus
  if (content_has_price) contentScore += 0.05;
  if (content_has_personalization) contentScore += 0.05;

  // Timing component
  let timingScore = 0.0;

  // Peak hours boost (based on general OnlyFans activity patterns)
  const peakHours = [11, 12, 13, 19, 20, 21, 22];
  const goodHours = [10, 14, 15, 16, 17, 18, 23];

  if (peakHours.includes(send_hour)) {
    timingScore += 1.0 * 0.4;
  } else if (goodHours.includes(send_hour)) {
    timingScore += 0.8 * 0.4;
  } else {
    timingScore += 0.4 * 0.4;
  }

  // Weekend boost
  if (send_dayofweek === 1 || send_dayofweek === 7) { // Sunday or Saturday
    timingScore += 0.1;
  } else if (send_dayofweek === 6) { // Friday
    timingScore += 0.05;
  }

  // Recency/frequency optimization
  let recencyScore = 1.0;
  if (hours_since_last_send < 2) recencyScore = 0.1;
  else if (hours_since_last_send < 4) recencyScore = 0.3;
  else if (hours_since_last_send < 8) recencyScore = 0.6;
  else if (hours_since_last_send <= 24) recencyScore = 1.0;
  else if (hours_since_last_send <= 72) recencyScore = 0.9;
  else recencyScore = 0.7;

  timingScore += recencyScore * 0.3;

  // Fan activity alignment
  timingScore += (fan_activity_score || 0.5) * 0.3;

  // Fan component
  let fanScore = 0.0;
  const fanSegmentMultipliers = {
    'WHALES': 1.2,
    'LOYALISTS': 1.0,
    'NIGHT_OWLS': 0.9,
    'TEASERS': 0.7,
    'BROWSERS': 0.5
  };

  fanScore += (fanSegmentMultipliers[fan_segment] || 0.7) * 0.4;
  fanScore += (fan_engagement_history || 0.5) * 0.3;

  // Price sensitivity adjustment
  if (content_category === 'PPV') {
    let priceSensitivityAdjust = 1.0 - (fan_price_sensitivity || 0.5) * 0.5;
    fanScore += priceSensitivityAdjust * 0.3;
  } else {
    fanScore += 0.3; // Non-paid content gets full points
  }

  // Environmental component
  let environmentScore = 0.0;
  environmentScore += (1.0 - (competitive_activity_score || 0.5)) * 0.4; // Less competition = better
  environmentScore += (seasonal_boost_factor || 1.0) * 0.3;
  environmentScore += (platform_health_score || 0.8) * 0.3;

  // Combine all components
  baseScore = (
    creatorScore * weights.creator +
    contentScore * weights.content +
    timingScore * weights.timing +
    fanScore * weights.fan +
    environmentScore * weights.environment
  );

  // Advanced adjustments

  // Momentum bonus for high-performing creators
  if (creator_tier === 'PREMIUM' && creator_recent_trend > 1.2) {
    baseScore *= 1.1;
  }

  // Novelty decay penalty
  if (content_novelty_score < 0.3) {
    baseScore *= 0.8;
  }

  // High-value fan segment bonus
  if (fan_segment === 'WHALES' && content_category === 'PPV') {
    baseScore *= 1.15;
  }

  // Time-of-day and fan segment alignment
  if (fan_segment === 'NIGHT_OWLS' && send_hour >= 22) {
    baseScore *= 1.1;
  }

  // Content-tier alignment bonus
  const tierContentAlignment = {
    'PREMIUM': ['PPV', 'CUSTOM'],
    'HIGH': ['PPV', 'CUSTOM', 'TIP'],
    'MED': ['PPV', 'BUMP'],
    'LOW': ['BUMP', 'TIP'],
    'NEW': ['BUMP']
  };

  if (tierContentAlignment[creator_tier] &&
      tierContentAlignment[creator_tier].includes(content_category)) {
    baseScore *= 1.05;
  }

  // Ensure score is within reasonable bounds
  return Math.max(0.0, Math.min(baseScore, 1.0));
""";

-- =====================================================================
-- MULTI-OBJECTIVE OPTIMIZATION FUNCTION
-- =====================================================================

CREATE OR REPLACE FUNCTION `layer_02_features.calculate_multi_objective_score`(
  primary_score NUMERIC,          -- Main slot score
  revenue_potential NUMERIC,      -- Expected revenue impact
  engagement_potential NUMERIC,   -- Expected engagement impact
  risk_score NUMERIC,            -- Risk of negative outcome
  strategic_value NUMERIC,       -- Long-term strategic value
  objectives JSON                 -- Dynamic objective weights
)
RETURNS NUMERIC
LANGUAGE js AS """
  // Parse objectives or use defaults
  let obj = {};
  try {
    obj = JSON.parse(objectives || '{}');
  } catch (e) {
    obj = {};
  }

  // Default objective weights
  const weights = {
    revenue: obj.revenue_weight || 0.35,
    engagement: obj.engagement_weight || 0.25,
    consistency: obj.consistency_weight || 0.20,
    growth: obj.growth_weight || 0.15,
    risk_mitigation: obj.risk_weight || 0.05
  };

  // Normalize inputs
  const normalizedPrimary = Math.max(0, Math.min(primary_score || 0, 1));
  const normalizedRevenue = Math.max(0, Math.min(revenue_potential || 0, 1));
  const normalizedEngagement = Math.max(0, Math.min(engagement_potential || 0, 1));
  const normalizedRisk = Math.max(0, Math.min(risk_score || 0, 1));
  const normalizedStrategic = Math.max(0, Math.min(strategic_value || 0, 1));

  // Calculate component scores
  const revenueScore = normalizedRevenue * weights.revenue;
  const engagementScore = normalizedEngagement * weights.engagement;
  const consistencyScore = normalizedPrimary * weights.consistency;
  const growthScore = normalizedStrategic * weights.growth;
  const riskScore = (1.0 - normalizedRisk) * weights.risk_mitigation; // Lower risk = higher score

  // Combine scores
  const finalScore = revenueScore + engagementScore + consistencyScore + growthScore + riskScore;

  // Apply diminishing returns for very high scores
  if (finalScore > 0.8) {
    return 0.8 + (finalScore - 0.8) * 0.5;
  }

  return Math.max(0.0, Math.min(finalScore, 1.0));
""";

-- =====================================================================
-- DYNAMIC FEATURE IMPORTANCE CALCULATOR
-- =====================================================================

CREATE OR REPLACE FUNCTION `layer_02_features.calculate_feature_importance`(
  historical_performance JSON,    -- Historical feature performance data
  creator_context JSON,          -- Creator-specific context
  market_conditions JSON         -- Current market conditions
)
RETURNS JSON
LANGUAGE js AS """
  // Default feature importance weights
  let importance = {
    timing: 0.25,
    content_quality: 0.30,
    fan_segmentation: 0.20,
    creator_performance: 0.15,
    market_conditions: 0.10
  };

  try {
    const hist = JSON.parse(historical_performance || '{}');
    const creator = JSON.parse(creator_context || '{}');
    const market = JSON.parse(market_conditions || '{}');

    // Adjust importance based on creator tier
    if (creator.tier === 'PREMIUM' || creator.tier === 'HIGH') {
      importance.content_quality += 0.05;
      importance.fan_segmentation += 0.05;
      importance.timing -= 0.05;
      importance.creator_performance -= 0.05;
    } else if (creator.tier === 'NEW' || creator.tier === 'LOW') {
      importance.timing += 0.05;
      importance.creator_performance += 0.05;
      importance.content_quality -= 0.05;
      importance.fan_segmentation -= 0.05;
    }

    // Adjust based on historical performance patterns
    if (hist.timing_correlation > 0.7) {
      importance.timing += 0.03;
    }
    if (hist.content_correlation > 0.7) {
      importance.content_quality += 0.03;
    }
    if (hist.fan_correlation > 0.7) {
      importance.fan_segmentation += 0.03;
    }

    // Adjust based on market volatility
    if (market.volatility > 0.8) {
      importance.market_conditions += 0.05;
      importance.timing += 0.02;
    }

    // Normalize to ensure weights sum to 1.0
    const total = Object.values(importance).reduce((sum, val) => sum + val, 0);
    Object.keys(importance).forEach(key => {
      importance[key] = importance[key] / total;
    });

  } catch (e) {
    // Return defaults if parsing fails
  }

  return JSON.stringify(importance);
""";

-- =====================================================================
-- ADVANCED CONTEXT AGGREGATION FUNCTION
-- =====================================================================

CREATE OR REPLACE FUNCTION `layer_02_features.aggregate_context_features`(
  creator_features JSON,
  content_features JSON,
  timing_features JSON,
  fan_features JSON,
  market_features JSON
)
RETURNS JSON
LANGUAGE js AS """
  let context = {
    composite_score: 0.0,
    confidence_level: 0.0,
    risk_factors: [],
    opportunity_factors: [],
    recommendations: []
  };

  try {
    const creator = JSON.parse(creator_features || '{}');
    const content = JSON.parse(content_features || '{}');
    const timing = JSON.parse(timing_features || '{}');
    const fan = JSON.parse(fan_features || '{}');
    const market = JSON.parse(market_features || '{}');

    // Calculate composite score
    context.composite_score = (
      (creator.score || 0.5) * 0.25 +
      (content.score || 0.5) * 0.30 +
      (timing.score || 0.5) * 0.25 +
      (fan.score || 0.5) * 0.15 +
      (market.score || 0.5) * 0.05
    );

    // Calculate confidence based on data completeness
    let completeness = 0;
    if (creator.score) completeness += 0.25;
    if (content.score) completeness += 0.30;
    if (timing.score) completeness += 0.25;
    if (fan.score) completeness += 0.15;
    if (market.score) completeness += 0.05;

    context.confidence_level = completeness;

    // Identify risk factors
    if (creator.recent_performance_decline) {
      context.risk_factors.push('creator_performance_declining');
    }
    if (content.novelty_score < 0.3) {
      context.risk_factors.push('low_content_novelty');
    }
    if (timing.frequency_risk > 0.7) {
      context.risk_factors.push('high_frequency_risk');
    }
    if (fan.engagement_trend < 0.5) {
      context.risk_factors.push('declining_fan_engagement');
    }

    // Identify opportunity factors
    if (creator.tier === 'PREMIUM' && creator.momentum > 1.2) {
      context.opportunity_factors.push('premium_creator_momentum');
    }
    if (content.historical_performance > 0.8) {
      context.opportunity_factors.push('high_performing_content');
    }
    if (timing.optimal_window) {
      context.opportunity_factors.push('optimal_timing_window');
    }
    if (fan.high_value_segment) {
      context.opportunity_factors.push('high_value_fan_segment');
    }

    // Generate recommendations
    if (context.composite_score > 0.8) {
      context.recommendations.push('proceed_with_confidence');
    } else if (context.composite_score > 0.6) {
      context.recommendations.push('proceed_with_monitoring');
    } else if (context.composite_score > 0.4) {
      context.recommendations.push('optimize_before_sending');
    } else {
      context.recommendations.push('reconsider_strategy');
    }

    if (context.risk_factors.length > 2) {
      context.recommendations.push('high_risk_mitigation_required');
    }

    if (context.opportunity_factors.length > 2) {
      context.recommendations.push('scale_for_maximum_impact');
    }

  } catch (e) {
    // Return minimal context if parsing fails
    context.composite_score = 0.5;
    context.confidence_level = 0.3;
  }

  return JSON.stringify(context);
""";

-- =====================================================================
-- INTELLIGENT FEATURE EXTRACTION FUNCTIONS
-- =====================================================================

-- Extract timing features for slot scoring
CREATE OR REPLACE FUNCTION `layer_02_features.extract_timing_features`(
  send_hour INT64,
  send_dayofweek INT64,
  creator_timezone STRING,
  hours_since_last_send NUMERIC,
  fan_activity_pattern JSON
)
RETURNS JSON
LANGUAGE js AS """
  let features = {
    hour_category: 'unknown',
    day_category: 'unknown',
    optimal_window: false,
    frequency_risk: 0.0,
    fan_alignment_score: 0.5,
    score: 0.5
  };

  try {
    // Hour categorization
    if (send_hour >= 6 && send_hour <= 11) features.hour_category = 'morning';
    else if (send_hour >= 12 && send_hour <= 17) features.hour_category = 'afternoon';
    else if (send_hour >= 18 && send_hour <= 23) features.hour_category = 'evening';
    else features.hour_category = 'night';

    // Day categorization
    if (send_dayofweek === 1 || send_dayofweek === 7) features.day_category = 'weekend';
    else if (send_dayofweek >= 2 && send_dayofweek <= 4) features.day_category = 'weekday_early';
    else features.day_category = 'weekday_late';

    // Optimal window detection
    const peakHours = [11, 12, 13, 19, 20, 21, 22];
    features.optimal_window = peakHours.includes(send_hour);

    // Frequency risk calculation
    if (hours_since_last_send < 2) features.frequency_risk = 0.9;
    else if (hours_since_last_send < 4) features.frequency_risk = 0.7;
    else if (hours_since_last_send < 8) features.frequency_risk = 0.4;
    else if (hours_since_last_send > 168) features.frequency_risk = 0.3;
    else features.frequency_risk = 0.1;

    // Fan activity alignment
    const fanPattern = JSON.parse(fan_activity_pattern || '{}');
    if (fanPattern.peak_hours && fanPattern.peak_hours.includes(send_hour)) {
      features.fan_alignment_score = 0.9;
    } else if (fanPattern.good_hours && fanPattern.good_hours.includes(send_hour)) {
      features.fan_alignment_score = 0.7;
    } else {
      features.fan_alignment_score = 0.4;
    }

    // Overall timing score
    let score = 0.0;
    score += features.optimal_window ? 0.3 : 0.1;
    score += (1.0 - features.frequency_risk) * 0.4;
    score += features.fan_alignment_score * 0.3;

    features.score = Math.max(0.0, Math.min(score, 1.0));

  } catch (e) {
    // Return defaults if parsing fails
  }

  return JSON.stringify(features);
""";

-- Extract content features for slot scoring
CREATE OR REPLACE FUNCTION `layer_02_features.extract_content_features`(
  content_category STRING,
  content_text STRING,
  content_length INT64,
  novelty_score NUMERIC,
  historical_performance NUMERIC,
  price_amount NUMERIC
)
RETURNS JSON
LANGUAGE js AS """
  let features = {
    category: content_category || 'unknown',
    length_category: 'unknown',
    sophistication_score: 0.5,
    price_tier: 'unknown',
    engagement_potential: 0.5,
    score: 0.5
  };

  try {
    // Length categorization
    if (content_length <= 30) features.length_category = 'very_short';
    else if (content_length <= 60) features.length_category = 'short';
    else if (content_length <= 120) features.length_category = 'medium';
    else if (content_length <= 200) features.length_category = 'long';
    else features.length_category = 'very_long';

    // Sophistication scoring
    let sophistication = 0.0;
    if (content_length >= 40) sophistication += 0.2;
    if (content_text && content_text.includes('$')) sophistication += 0.1;
    if (content_text && /[ðŸ”¥ðŸ’•ðŸ˜˜â¤ï¸ðŸ’‹]/.test(content_text)) sophistication += 0.2;
    if (content_text && content_text.includes('{{')) sophistication += 0.2;
    if (content_length >= 50 && content_length <= 150) sophistication += 0.3;
    features.sophistication_score = Math.min(sophistication, 1.0);

    // Price tier classification
    if (price_amount === null || price_amount === 0) features.price_tier = 'free';
    else if (price_amount <= 5) features.price_tier = 'low';
    else if (price_amount <= 15) features.price_tier = 'medium';
    else if (price_amount <= 30) features.price_tier = 'high';
    else features.price_tier = 'premium';

    // Engagement potential
    let engagement = 0.0;
    engagement += (novelty_score || 0.5) * 0.4;
    engagement += (historical_performance || 0.5) * 0.3;
    engagement += features.sophistication_score * 0.2;
    engagement += (features.length_category === 'medium' || features.length_category === 'long') ? 0.1 : 0.0;
    features.engagement_potential = Math.min(engagement, 1.0);

    // Overall content score
    let score = 0.0;
    const categoryScores = {
      'PPV': 0.9, 'CUSTOM': 0.8, 'TIP': 0.6, 'BUMP': 0.5, 'RENEW': 0.7
    };
    score += (categoryScores[content_category] || 0.5) * 0.3;
    score += features.engagement_potential * 0.4;
    score += (novelty_score || 0.5) * 0.3;

    features.score = Math.max(0.0, Math.min(score, 1.0));

  } catch (e) {
    // Return defaults if parsing fails
  }

  return JSON.stringify(features);
""";

-- =====================================================================
-- METADATA LOGGING
-- =====================================================================

-- Log successful creation
INSERT INTO `layer_10_metadata.build_log` (
  layer, component, status, message, created_at
)
VALUES (
  'L2', 'udf_slot_score_v2',
  'SUCCESS',
  'Created advanced slot scoring engine with multi-objective optimization and AI-powered feature extraction',
  CURRENT_TIMESTAMP()
);

-- Success message
SELECT
  'L2.01 COMPLETE' as status,
  'Advanced slot scoring UDFs created with intelligent feature weighting and multi-objective optimization' as message,
  CURRENT_TIMESTAMP() as completed_at;